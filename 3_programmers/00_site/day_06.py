# Day 06

# %%

# 1

# 문제 설명
# S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다.
# 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다.
# 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

# 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다.
# 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

# 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때,
# 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

# 제한사항
# d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
# d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
# budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

# 입출력  예
# d	            budget	result
# [1,3,2,5,4]	9	    3
# [2,2,3,3]	    10	    4


#

d = [1, 3, 2, 5, 4]
budget = 9

# d 를 적은 순서대로

# d.sort()
# amonut = 0
# count = 0

# for i in range(len(d)):

#     amonut += d[i]
#     print(amonut)

#     if amonut <= buget:
#         count += 1


def solution(d, budget):
    answer = 0

    d.sort()
    amonut = 0
    count = 0

    for i in range(len(d)):
        amonut += d[i]
        print(amonut)

        if amonut <= budget:
            count += 1

    answer = count

    return answer


solution(d, budget)

# %%

# 2 **
# 숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서,
# 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

# 예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다.
# 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

# 제한사항
# 1 ≤ p의 길이 ≤ 18
# p의 길이 ≤ t의 길이 ≤ 10,000
# t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.

# 입출력 예
# t	                p	    result
# "3141592"	        "271"	2
# "500220839878"	"7"	    8
# "10203"	        "15"	3

t = "3141592"
p = "271"


def solution(t, p):
    answer = 0

    index = len(p)
    for i in range(len(t) - index + 1):
        if t[i:i + index] <= p:
            answer += 1

    return answer

# %%

# 3 **

# 문제 설명
# 문자열 s는 한 개 이상의 단어로 구성되어 있습니다.
# 각 단어는 하나 이상의 공백문자로 구분되어 있습니다.
# 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.

# 제한 사항
# 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.
# 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.

# 입출력 예
# s	                return
# "try hello world"	"TrY HeLlO WoRlD"


s = "tsry hello world"


def solution(s):
    answer = ''
    new_list = s.split(' ')
    for i in new_list:
        for j in range(len(i)):
            if j % 2 == 0:
                answer += i[j].upper()
            else:
                answer += i[j].lower()
        answer += ' '
    return answer[0:-1]


solution(s)

# %%

# 4 **

# 한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다.
# 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다.
# 예를 들어, 5명의 학생이 있고,
# 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다.
# 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다.
# 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.
# 한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때,
# 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.

# 제한사항
# 3 ≤ number의 길이 ≤ 13
# -1,000 ≤ number의 각 원소 ≤ 1,000
# 서로 다른 학생의 정수 번호가 같을 수 있습니다.

# 입출력 예
# number	                    result
# [-2, 3, 0, 2, -5]	            2
# [-3, -2, -1, 0, 1, 2, 3]	    5
# [-1, 1, -1, 1]	            0


def solution(number):
    answer = 0
    l = len(number)
    for i in range(l):
        for j in range(i+1, l):
            for k in range(j+1, l):
                if number[i] + number[j] + number[k] == 0:
                    answer += 1
    return answer

# %%

# 5 **
# 명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다.
# 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다.
# 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

# 아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

# 명함 번호	가로 길이	세로 길이
# 1	60	50
# 2	30	70
# 3	60	30
# 4	80	40
# 가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다.
# 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

# 모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다.
# 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

# 제한사항
# sizes의 길이는 1 이상 10,000 이하입니다.
# sizes의 원소는 [w, h] 형식입니다.
# w는 명함의 가로 길이를 나타냅니다.
# h는 명함의 세로 길이를 나타냅니다.
# w와 h는 1 이상 1,000 이하인 자연수입니다.

# 입출력 예
# sizes	                                        result
# [[60, 50], [30, 70], [60, 30], [80, 40]]	    4000
# [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]] 	120
# [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]     133


def solution(sizes):
    # 1. 명함 지갑의 가로, 세로 길이 후보 list 변수 w, h 생성한다
    w = []  # 명함 지갑의 가로 길이 후보 리스트
    h = []  # 명함 지갑의 세로 길이 후보 리스트

    # 2. 주어진 명함들을 for 문을 돌면서 더 큰 값을 w, 작은 값을 h에 저장한다
    for size in sizes:
        if size[0] > size[1]:
            w.append(size[0])
            h.append(size[1])
        else:
            w.append(size[1])
            h.append(size[0])

    # 3. 각 w, h 리스트에서 가장 큰 값을 곱한다
    return max(w) * max(h)
