# 시간 복잡도 (Time_complexity)

# 1. 알고리즘 복잡도 계산이 필요한 이유
# - 하나의 문제를 푸는 알고리즘은 다양할 수 있음
#   ex) 정수의 절대값 구하기 -> 제곱 후 루트 // 정수 음수 확인 후 음수일때 -1 곱하기

# 2. 알고리즘 복잡도 계산 항목
# 어떤 알고리즘이 좋은건가?? 그것을 판단하는 기준
# - 시간 복잡도 : 알고리즘 실행 속도 (가장 중요)
# - 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

# 반복문을 가지고 시간 복잡도를 계산한다
# ex) 자동차 문열기 -> 닫기 -> 시동시간 -> 서울에서 부산가기 -> 부산에서 서울가기
# 가장 시간이 오래걸리는 부분을 반복해서 (서울에서 부산가기) 시간 복잡도를 계산한다.

# - 표기법 
# Big o (알고리즘 최악의 실행 시간을 표기) 이것이 중요!
# 오메가 (최상의 실행시간을 표기)
# 세타 (알고리즘의 평균 실행시간 표기)


# 연습1 : 1부터 n까지의 합을 구하는 알고리즘

# 1
def sum_all_1(n):
    total = 0
    for num in range(1,n+1):
        total += num
    return total

sum_1 = sum_all_1(100)

# 2
def sum_all_2(n):
    return int(n * (n+1)/2)

sum_2 = sum_all_2(100)

# Big o 표기법
# 1번은 O(n)
# 2번은 O(1)
# 즉, 2번이 실행속도가 빠르다.
